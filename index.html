<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive STL Assembly Viewer</title>
    <script src="https://unpkg.com/@azure/web-pubsub-client@1.0.0-beta.1/dist/web-pubsub-client.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            max-width: 400px;
            font-size: 14px;
            display: none;
        }

        #controls {
            position: absolute;
            top: 50px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            display: none;
        }

        #text-controls {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            display: none;
        }

        #text-controls.active {
            display: block;
        }

        #text-controls h3 {
            margin: 0 0 10px 0;
            color: #fff;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        .text-panel-control {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .text-panel-control h4 {
            margin: 0 0 8px 0;
            color: #ffd700;
            font-size: 13px;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
            gap: 10px;
        }

        .control-row label {
            width: 60px;
            font-size: 11px;
        }

        .control-row input[type="range"] {
            flex: 1;
            height: 20px;
        }

        .control-row input[type="number"] {
            width: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .control-row select {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 3px;
            border-radius: 3px;
        }

        .control-row select option {
            background: #333;
        }

        .control-row textarea {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px;
            border-radius: 3px;
            resize: vertical;
        }

        #toggle-text-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 20;
        }

        #toggle-text-controls:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .text-preview {
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            max-height: 40px;
            overflow: hidden;
        }

        #controls label {
            margin-right: 5px;
        }

        #controls input[type="number"] {
            width: 60px;
            margin: 2px;
        }

        #controls input[type="checkbox"] {
            margin: 2px;
        }

        #controls button {
            margin: 5px 0;
            padding: 5px;
        }

        #mobile-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        #mobile-controls button {
            padding: 10px 15px;
            font-size: 16px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation;
        }

        #mobile-controls button:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        @media (max-width: 600px) {
            #mobile-controls button {
                padding: 8px 12px;
                font-size: 14px;
            }
        }

        .panel-text {
            position: absolute;
            width: 200px;
            height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            font-family: 'Kalam', cursive;
            color: #2c3e50;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .handwritten {
            font-family: 'Kalam', cursive;
            font-weight: 700;
            font-size: 18px;
            line-height: 1.4;
            letter-spacing: 0.5px;
            text-shadow: 0.5px 0.5px 0px rgba(0, 0, 0, 0.1);
        }

        .handwritten-large {
            font-size: 22px;
            font-weight: 700;
        }

        .handwritten-small {
            font-size: 16px;
        }

        .char-1 {
            transform: rotate(-1deg);
            display: inline-block;
        }

        .char-2 {
            transform: rotate(0.5deg);
            display: inline-block;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="info"></div>
    <div id="controls"></div>
    <div id="text-controls">
        <h3>Text Panel Controls</h3>
    </div>
    <button id="toggle-text-controls">Toggle Controls</button>
    <div id="mobile-controls"></div>

    <script>
        // Config: Update to your Function App URL
        const FUNCTION_APP_URL = 'https://shmorgasbord.azurewebsites.net'; // Or '/api' if co-hosted

        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const movableMeshes = [];
        const panelTexts = [];
        const textPanels = [];
        window.allTextPanels = [];
        const availableFonts = ['Kalam', 'Dancing Script', 'Pacifico']; // Example fonts

        // Create initial boards (placeholders for STL meshes)
        [0xff0000, 0x00ff00, 0xffff00].forEach((color, i) => {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(i * 2 - 2, 0, 0);
            scene.add(mesh);
            movableMeshes.push(mesh);
        });

        function createHandwritingTexture(text, color, fontFamily, fontSize, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = color;
            ctx.font = `${fontSize || 20}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const lines = text.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, width / 2, height / 2 - (lines.length - 1) * 10 + i * 20);
            });
            return new THREE.CanvasTexture(canvas);
        }

        function createEmptyTexture(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(0, 0, width, height);
            return new THREE.CanvasTexture(canvas);
        }

        function createTextPanel(messageFunc, index, fontFamily = 'Kalam', panelSize = null, type = 'text') {
            const width = panelSize?.width || (type === 'text' ? 400 : 227.5);
            const height = panelSize?.height || (type === 'text' ? 200 : 455);
            const geometry = new THREE.PlaneGeometry(width, height);
            let textureData;
            if (type === 'text') {
                textureData = createHandwritingTexture(messageFunc(), '#000000', fontFamily, null, width * 2, height * 2);
            } else {
                textureData = createEmptyTexture(width * 2, height * 2);
            }
            const material = new THREE.MeshBasicMaterial({
                map: textureData.texture,
                transparent: true,
                opacity: 0.95,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false
            });
            const panel = new THREE.Mesh(geometry, material);
            panel.userData = { textureData, messageFunc, index, type };
            return panel;
        }

        function updatePanelTexture(panelMesh, panelData) {
            let textureData;
            if (panelData.type === 'text') {
                textureData = createHandwritingTexture(panelData.text || '', '#000000', panelData.font, null, panelData.baseSize.width * 2, panelData.baseSize.height * 2);
            } else {
                textureData = createDrawingTexture(panelData.drawingData, panelData.baseSize); // Assume implemented
            }
            panelMesh.material.map = textureData.texture;
            panelMesh.material.needsUpdate = true;
        }

        function createDrawingTexture(drawingData, panelSize) {
            const canvas = document.createElement('canvas');
            canvas.width = panelSize.width * 2;
            canvas.height = panelSize.height * 2;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (drawingData) {
                drawingData.forEach(stroke => {
                    ctx.beginPath();
                    ctx.strokeStyle = stroke.color || '#000000';
                    ctx.lineWidth = 2;
                    ctx.moveTo(stroke.points[0][0] * 2, stroke.points[0][1] * 2);
                    for (let i = 1; i < stroke.points.length; i++) {
                        ctx.lineTo(stroke.points[i][0] * 2, stroke.points[i][1] * 2);
                    }
                    ctx.stroke();
                });
            }
            return new THREE.CanvasTexture(canvas);
        }

        function initializeTextControls() {
            const controls = document.getElementById('text-controls');
            controls.innerHTML = '<h3>Text Panel Controls</h3>';
            window.allTextPanels.forEach((panel, index) => {
                const div = document.createElement('div');
                div.className = 'text-panel-control';
                div.innerHTML = `
                    <h4>${panel.name}</h4>
                    <div class="control-row">
                        <label>Text:</label>
                        <textarea data-panel-index="${index}" data-prop="text">${panel.text || ''}</textarea>
                    </div>
                    <div class="control-row">
                        <label>Font:</label>
                        <select data-panel-index="${index}" data-prop="font">
                            ${availableFonts.map(f => `<option ${f === panel.font ? 'selected' : ''}>${f}</option>`).join('')}
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Size:</label>
                        <input type="range" min="50" max="150" value="${panel.size}" data-panel-index="${index}" data-prop="size">
                    </div>
                `;
                controls.appendChild(div);
            });
        }

        function saveState() {
            const state = JSON.stringify(window.allTextPanels, null, 2);
            localStorage.setItem('textPanelState', state);
        }

        function loadState() {
            const state = localStorage.getItem('textPanelState');
            if (state) {
                window.allTextPanels = JSON.parse(state);
                textPanels.forEach((p, i) => updatePanelTexture(p, window.allTextPanels[i]));
                initializeTextControls();
            }
        }

        function exportState() {
            const state = JSON.stringify(window.allTextPanels, null, 2);
            const blob = new Blob([state], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'textPanelState.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetState() {
            textPanels = [];
            panelTexts = [];
            window.allTextPanels = [];
            scene.remove(...scene.children.filter(child => child.userData && child.userData.type));
            localStorage.removeItem('textPanelState');

            [0, 1, 2].forEach(panelIndex => {
                const newIndex = window.allTextPanels.length;
                const newName = `HandDrawn ${newIndex + 1}`;
                const newFont = availableFonts[0];
                const newSize = 100;
                const newOffset = new THREE.Vector3(-11.4, 152, -623.8);
                const newRotation = new THREE.Euler(-Math.PI / 2, Math.PI / 2, Math.PI);
                const newPanelSize = { width: 229, height: 295 };
                const newMessageFunc = () => '';
                const newPanel = createTextPanel(newMessageFunc, newIndex + 100, newFont, newPanelSize, 'draw');
                newPanel.rotation.x = movableMeshes[panelIndex].rotation.x;
                scene.add(newPanel);
                const newPanelObj = {
                    stlMesh: movableMeshes[panelIndex],
                    textPanel: newPanel,
                    offset: newOffset,
                    rotationOffset: newRotation
                };
                panelTexts.push(newPanelObj);
                textPanels.push(newPanel);
                window.allTextPanels.push({
                    name: newName,
                    panelObj: newPanelObj,
                    panel: newPanel,
                    font: newFont,
                    size: newSize,
                    isMain: false,
                    assignedPanel: panelIndex,
                    stlMesh: movableMeshes[panelIndex],
                    text: null,
                    drawingData: null,
                    isDynamic: false,
                    type: 'draw',
                    baseSize: newPanelSize
                });
            });
            initializeTextControls();
            saveState();
            console.info('State reset to default.');
        }

        function addNewTextPanel() {
            const typeChoice = prompt("Enter type (1 for typed text, 2 for hand drawn):", "1");
            const isTyped = typeChoice === "1";
            let initialText = null;
            if (isTyped) {
                initialText = prompt("Enter the message text (use \\n for line breaks):", "New message\nEdit me");
                if (!initialText) return;
            }
            const panelStr = prompt("Assign to panel (0=Pink, 1=Green, 2=Blue):", "0");
            const newAssigned = parseInt(panelStr) || 0;

            const newIndex = window.allTextPanels.length;
            const newName = `Custom ${newIndex + 1}`;
            const newFont = availableFonts[0];
            const newSize = isTyped ? 76 : 100;
            const newOffset = new THREE.Vector3(-11.4, 100, -600);
            const newRotation = new THREE.Euler(-Math.PI / 2, Math.PI / 2, Math.PI);
            const newPanelSize = isTyped ? { width: 400, height: 200 } : { width: 227.5, height: 455 };
            const newMessageFunc = isTyped ? () => initialText : () => '';
            const newPanel = createTextPanel(newMessageFunc, newIndex + 100, newFont, newPanelSize, isTyped ? 'text' : 'draw');
            newPanel.rotation.x = movableMeshes[newAssigned].rotation.x;
            scene.add(newPanel);
            const newPanelObj = {
                stlMesh: movableMeshes[newAssigned],
                textPanel: newPanel,
                offset: newOffset,
                rotationOffset: newRotation
            };
            panelTexts.push(newPanelObj);
            textPanels.push(newPanel);
            window.allTextPanels.push({
                name: newName,
                panelObj: newPanelObj,
                panel: newPanel,
                font: newFont,
                size: newSize,
                isMain: false,
                assignedPanel: newAssigned,
                stlMesh: movableMeshes[newAssigned],
                text: initialText,
                drawingData: null,
                isDynamic: false,
                type: isTyped ? 'text' : 'draw',
                baseSize: newPanelSize
            });
            initializeTextControls();
            saveState();
        }

        document.getElementById('toggle-text-controls').addEventListener('click', () => {
            const panel = document.getElementById('text-controls');
            panel.classList.toggle('active');
        });

        setTimeout(() => {
            document.getElementById('save-state')?.addEventListener('click', saveState);
            document.getElementById('load-state')?.addEventListener('click', () => loadState());
            document.getElementById('export-state')?.addEventListener('click', exportState);
            document.getElementById('reset-state')?.addEventListener('click', resetState);
            document.getElementById('add-new-text')?.addEventListener('click', addNewTextPanel);
        }, 100);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateModeIndicator();
        });

        // PubSub Integration
        let pubsubClient = null;
        let myUserId = crypto.randomUUID();
        let roomId = window.location.pathname.slice(1);

        // Auto-generate room if missing
        if (!roomId) {
            roomId = crypto.randomUUID().slice(0, 8);
            window.history.replaceState(null, '', `/${roomId}`);
        }

        // Show room in UI
        function updateRoomUI() {
            const roomDiv = document.getElementById('room-info');
            if (!roomDiv) {
                const controls = document.getElementById('text-controls');
                const roomInfo = document.createElement('div');
                roomInfo.id = 'room-info';
                roomInfo.innerHTML = `
                    <h4>Room: ${roomId}</h4>
                    <button onclick="navigator.clipboard.writeText(window.location.href); alert('Link copied!');">Copy Link</button>
                    <button id="lock-room" onclick="lockRoom()">Lock Room (Premium)</button>
                `;
                controls.insertBefore(roomInfo, controls.firstChild);
            }
        }

        // Placeholder paid lock
        window.lockRoom = function() {
            const password = prompt('Set password for this room:');
            if (password) {
                localStorage.setItem(`room_${roomId}_password`, password);
                alert('Room locked! (Payments placeholder - validation coming soon)');
            }
        };

        // Get current state
        function getCurrentState() {
            return window.allTextPanels.map(panel => ({
                name: panel.name,
                text: panel.text,
                drawingData: panel.drawingData,
                font: panel.font,
                size: panel.size,
                type: panel.type,
                baseSize: panel.baseSize
            }));
        }

        // Apply remote update
        function handleRemoteUpdate(msg) {
            const { type, panelIndex, updates } = msg;
            const panel = window.allTextPanels[panelIndex];
            if (!panel) return;

            switch (type) {
                case 'fullState':
                    window.allTextPanels = msg.state.map((state, i) => {
                        const existing = window.allTextPanels[i] || state;
                        return { ...existing, ...state };
                    });
                    textPanels.forEach((p, i) => updatePanelTexture(p, window.allTextPanels[i]));
                    break;
                case 'updatePanel':
                    Object.assign(panel, updates);
                    updatePanelTexture(textPanels[panelIndex], panel);
                    break;
                case 'addStroke':
                    if (!panel.drawingData) panel.drawingData = [];
                    panel.drawingData.push(updates.stroke);
                    updatePanelTexture(textPanels[panelIndex], panel);
                    break;
            }
            saveState();
        }

        // Send update
        async function sendUpdate(type, panelIndex, updates = {}) {
            if (!pubsubClient) return;
            const msg = { userId: myUserId, type, panelIndex, ...updates };
            await pubsubClient.sendToGroup(roomId, JSON.stringify(msg), 'json');
        }

        // Connect to PubSub
        async function connectPubSub() {
            try {
                const password = localStorage.getItem(`room_${roomId}_password`) || '';
                const url = `${FUNCTION_APP_URL}/api/negotiate?group=${roomId}${password ? `&password=${encodeURIComponent(password)}` : ''}`;
                const res = await fetch(url);
                if (!res.ok) throw new Error('Negotiation failed');
                const { url: connectUrl } = await res.json();

                pubsubClient = new WebPubSubClient(connectUrl, myUserId);
                pubsubClient.on('connected', async () => {
                    console.log('Connected to room:', roomId);
                    await pubsubClient.joinGroup(roomId);
                    sendUpdate('fullState', -1, { state: getCurrentState() });
                });
                pubsubClient.on('group-message', (e) => {
                    try {
                        const msg = JSON.parse(e.message.data);
                        if (msg.userId !== myUserId) handleRemoteUpdate(msg); // Avoid echo
                    } catch (err) {
                        console.error('Invalid message:', err);
                    }
                });
                pubsubClient.on('disconnected', () => console.log('Disconnected'));
                await pubsubClient.start();
            } catch (err) {
                console.error('PubSub connect failed:', err);
                alert('Connection failedâ€”check console and retry.');
            }
        }

        // Hook into your controls
        function setupCollabHooks() {
            document.querySelectorAll('input[type="text"], textarea').forEach(input => {
                input.addEventListener('input', (e) => {
                    const panelIndex = e.target.dataset.panelIndex;
                    if (panelIndex) sendUpdate('updatePanel', panelIndex, { text: e.target.value });
                });
            });

            // Placeholder for drawing (implement canvas stroke event)
            // Example: Assume drawingCanvas.on('strokeEnd', (stroke) => sendUpdate('addStroke', panelIndex, { stroke }));

            document.querySelectorAll('select, input[type="range"]').forEach(el => {
                el.addEventListener('change', (e) => {
                    const panelIndex = e.target.dataset.panelIndex;
                    if (panelIndex) {
                        const prop = e.target.dataset.prop;
                        sendUpdate('updatePanel', panelIndex, { [prop]: e.target.value });
                    }
                });
            });
        }

        // Initialize
        [0, 1, 2].forEach(panelIndex => {
            const newIndex = window.allTextPanels.length;
            const newName = `HandDrawn ${newIndex + 1}`;
            const newFont = availableFonts[0];
            const newSize = 100;
            const newOffset = new THREE.Vector3(-11.4, 152, -623.8);
            const newRotation = new THREE.Euler(-Math.PI / 2, Math.PI / 2, Math.PI);
            const newPanelSize = { width: 229, height: 295 };
            const newMessageFunc = () => '';
            const newPanel = createTextPanel(newMessageFunc, newIndex + 100, newFont, newPanelSize, 'draw');
            newPanel.rotation.x = movableMeshes[panelIndex].rotation.x;
            scene.add(newPanel);
            const newPanelObj = {
                stlMesh: movableMeshes[panelIndex],
                textPanel: newPanel,
                offset: newOffset,
                rotationOffset: newRotation
            };
            panelTexts.push(newPanelObj);
            textPanels.push(newPanel);
            window.allTextPanels.push({
                name: newName,
                panelObj: newPanelObj,
                panel: newPanel,
                font: newFont,
                size: newSize,
                isMain: false,
                assignedPanel: panelIndex,
                stlMesh: movableMeshes[panelIndex],
                text: null,
                drawingData: null,
                isDynamic: false,
                type: 'draw',
                baseSize: newPanelSize
            });
        });

        initializeTextControls();
        saveState();

        window.addEventListener('load', async () => {
            updateRoomUI();
            setupCollabHooks();
            await connectPubSub();
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>